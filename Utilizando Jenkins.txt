Implementação de CI/CD com Jenkins e Docker
Este documento descreve o processo de implementação de um pipeline de Integração e Entrega Contínua (CI/CD) usando Jenkins e Docker para automatizar o deploy da aplicação de chatbot.

1. Configuração Inicial do Ambiente
Instalação do Jenkins: O Jenkins foi instalado e configurado em um servidor Ubuntu, servindo como a ferramenta central para a automação do pipeline.

Instalação do Docker: O Docker foi instalado no mesmo servidor para permitir a criação de imagens e a execução da aplicação em containers.

Configuração de Credenciais: As credenciais SSH foram configuradas no Jenkins, permitindo que a ferramenta se conectasse ao repositório Git e buscasse as alterações do projeto.

2. Criação do Jenkinsfile
Um arquivo Jenkinsfile foi criado na raiz do projeto para definir o pipeline de CI/CD. Este arquivo automatizou as seguintes etapas:

Checkout: Buscou o código mais recente do repositório Git.

Build e Deploy: Conduziu a construção da imagem Docker e o deploy da aplicação.

3. Fluxo de Execução do Pipeline
A cada git push para o branch main no GitHub, o Jenkins disparou automaticamente o pipeline com as seguintes etapas:

Limpeza do Ambiente: O container Docker antigo da aplicação (chatbot-container) foi parado e removido, evitando conflitos de porta.

Build da Imagem Docker: A imagem Docker (chatbot-flask) foi construída a partir do Dockerfile do projeto. Durante a build, o pip instalou as dependências do requirements.txt.

Execução do Container: Um novo container foi criado e iniciado em segundo plano (-d) a partir da nova imagem Docker. A porta 5000 do container foi mapeada para a porta 5000 do host, tornando a aplicação acessível.

4. Resolução de Problemas (Troubleshooting)
Durante o desenvolvimento do pipeline, diversos problemas foram encontrados e resolvidos:

Conflitos de Merge: Inicialmente, um git pull --rebase resultou em um conflito no arquivo requirements.txt. Isso foi resolvido manualmente, editando o arquivo e continuando o rebase.

Compatibilidade de Bibliotecas: A aplicação falhou ao iniciar devido a uma incompatibilidade entre as versões do Flask e Werkzeug. O erro ImportError: cannot import name 'url_quote' foi corrigido ao atualizar as versões das bibliotecas no requirements.txt.

Dependências do NLTK: O container parava logo após iniciar devido a um erro LookupError: Resource punkt not found. Isso ocorreu porque a biblioteca NLTK, embora instalada, precisava que o pacote de dados punkt fosse baixado. A solução foi adicionar um passo de download no Dockerfile.

5. Resultado Final
Após a resolução dos problemas, o pipeline foi executado com sucesso. O container chatbot-container foi iniciado e está em execução. A aplicação se tornou acessível pela porta 5000, e a interface do chatbot pode ser visualizada no navegador, confirmando o deploy contínuo e automatizado da aplicação.
